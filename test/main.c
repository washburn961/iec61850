#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include "goose.h"

// Writes the generated byte stream to a binary file
void write_byte_stream_to_file(uint8_t* byte_stream, size_t length, const char* filename) {
    FILE* file = fopen(filename, "wb");
    if (file == NULL) {
        perror("Failed to open file for writing");
        return;
    }
    fwrite(byte_stream, sizeof(uint8_t), length, file);
    fclose(file);
    printf("Byte stream written to file: %s\n", filename);
}

// Sample data from the provided GOOSE frame
void test_goose_encode() {
    // Initialize the source and destination MAC addresses
    uint8_t source[MAC_ADDRESS_SIZE] = { 0x00, 0x30, 0xa7, 0x03, 0xc1, 0x53 };
    uint8_t destination[MAC_ADDRESS_SIZE] = { 0x01, 0x0c, 0xcd, 0x01, 0x00, 0x01 };

    // Initialize the appID
    uint8_t app_id[APP_ID_SIZE] = { 0x00, 0x05 };

    // Initialize the GOOSE handle
    goose_handle* handle = goose_init(source, destination, app_id);

    // Set the goosePdu fields according to the screenshot
    const char* gocbRef = "SE01100CS01CFG/LLN0$GO$AA3SE01100CS01G5";
    const char* dataset = "SE01100CS01CFG/LLN0$AA3SE01100CS01G5";
    const char* go_id = "AA3AL20101$SE01100CS01G5";

    uint16_t time_allowed_to_live = goose_htons(2000);
    uint64_t t = goose_htonll(1695149275408396764);  // Time in the format from screenshot (UNIX epoch in nanoseconds)
    uint32_t st_num = goose_htonl(1);
    uint32_t sq_num = goose_htonl(162924);
    uint8_t simulation = 0;
    uint8_t conf_rev = 1;
    uint8_t nds_com = 0;

    // Set values using ber_set for each PDU field
    ber_set(&(handle->frame->pdu_list.gocbref), (uint8_t*)gocbRef, strlen(gocbRef));
    ber_set(&(handle->frame->pdu_list.dataset), (uint8_t*)dataset, strlen(dataset));
    ber_set(&(handle->frame->pdu_list.go_id), (uint8_t*)go_id, strlen(go_id));
    ber_set(&(handle->frame->pdu_list.time_allowed_to_live), (uint8_t*)&time_allowed_to_live, sizeof(time_allowed_to_live));
    ber_set(&(handle->frame->pdu_list.t), (uint8_t*)&t, sizeof(t));
    ber_set(&(handle->frame->pdu_list.st_num), (uint8_t*)&st_num, sizeof(st_num));
    ber_set(&(handle->frame->pdu_list.sq_num), (uint8_t*)&sq_num, sizeof(sq_num));
    ber_set(&(handle->frame->pdu_list.simulation), (uint8_t*)&simulation, sizeof(simulation));
    ber_set(&(handle->frame->pdu_list.conf_rev), (uint8_t*)&conf_rev, sizeof(conf_rev));
    ber_set(&(handle->frame->pdu_list.nds_com), (uint8_t*)&nds_com, sizeof(nds_com));
    //ber_set(&(handle->frame->pdu_list.num_dataset_entries), (uint8_t*)&num_dataset_entries, sizeof(num_dataset_entries));

    // Add the dataset entries
    uint8_t boolean_false = 0;
    for (int i = 0; i < 4; i++) {
        goose_all_data_entry_add(handle, 0x83, sizeof(boolean_false), &boolean_false);
    }

    // Encode the frame
    goose_encode(handle);

    // Print the encoded byte stream
    printf("Encoded GOOSE frame (length: %zu bytes):\n", handle->length);
    for (size_t i = 0; i < handle->length; i++) {
        printf("%02x ", handle->byte_stream[i]);
        if ((i + 1) % 16 == 0) printf("\n");
    }

    write_byte_stream_to_file(handle->byte_stream, handle->length, "goose_frame.bin");

    // Clean up
    goose_free(handle);
}

int main() {
    test_goose_encode();
    return 0;
}
